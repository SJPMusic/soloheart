<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SoloHeart - Adventure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/confrontation-log.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            min-height: 100vh;
            font-family: 'Georgia', serif;
        }
        
        /* Main Layout */
        .gameplay-layout {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 0;
            height: 100vh;
        }
        
        @media (max-width: 768px) {
            .gameplay-layout {
                grid-template-columns: 1fr;
            }
            .sidebar-tools {
                display: none;
            }
        }
        
        /* Main Game Area */
        .main-game-area {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .game-container {
            flex: 1;
            overflow-y: auto;
            scroll-behavior: smooth;
            padding: 1rem;
            padding-bottom: 120px; /* Space for input */
        }
        
        /* Message Styling */
        .message {
            margin-bottom: 2rem;
            animation: fadeIn 0.6s ease-out;
        }
        
        .message.dm {
            text-align: left;
        }
        
        .message.player {
            text-align: right;
        }
        
        .message-content {
            display: inline-block;
            max-width: 85%;
            padding: 1.5rem;
            border-radius: 1.5rem;
            line-height: 1.8;
            word-wrap: break-word;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .message.dm .message-content {
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(148, 163, 184, 0.2);
            color: #e2e8f0;
            backdrop-filter: blur(10px);
        }
        
        .message.player .message-content {
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
            color: white;
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.3);
        }
        
        /* Markdown Rendering */
        .markdown-content {
            color: #e2e8f0;
        }
        
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #fbbf24;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .markdown-content p {
            margin-bottom: 1rem;
        }
        
        .markdown-content strong {
            color: #fbbf24;
        }
        
        .markdown-content em {
            color: #94a3b8;
            font-style: italic;
        }
        
        .markdown-content blockquote {
            border-left: 4px solid #fbbf24;
            padding-left: 1rem;
            margin: 1rem 0;
            color: #94a3b8;
        }
        
        /* Input Container */
        .input-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 1.5rem;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(15px);
            border-top: 1px solid rgba(148, 163, 184, 0.2);
            z-index: 100;
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .input-container .max-w-4xl {
            max-width: none;
        }
        
        /* Loading States */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(251, 191, 36, 0.3);
            border-radius: 50%;
            border-top-color: #fbbf24;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes fadeIn {
            from { 
                opacity: 0; 
                transform: translateY(20px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }
        
        /* Typing Indicator */
        .typing-indicator {
            display: none;
            padding: 1.5rem;
            color: #94a3b8;
            font-style: italic;
            text-align: left;
            animation: pulse 2s infinite;
        }
        
        .typing-indicator.show {
            display: block;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        /* Error Handling */
        .error-banner {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 1rem 0;
            color: #fca5a5;
            text-align: center;
            animation: slideIn 0.5s ease-out;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .retry-button {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #fca5a5;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 1rem;
            font-weight: 600;
        }
        
        .retry-button:hover {
            background: rgba(239, 68, 68, 0.3);
            transform: translateY(-2px);
        }
        
        /* Header */
        .header {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(15px);
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            padding: 1rem;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        /* Save Indicator */
        .save-indicator {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: rgba(34, 197, 94, 0.9);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 0.875rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 20;
            backdrop-filter: blur(10px);
        }
        
        .save-indicator.show {
            opacity: 1;
        }
        
        /* Sidebar Tools */
        .sidebar-tools {
            background: rgba(15, 23, 42, 0.9);
            border-left: 1px solid rgba(148, 163, 184, 0.2);
            padding: 1rem;
            overflow-y: auto;
            height: 100vh;
        }
        
        .sidebar-tools h3 {
            color: #fbbf24;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            padding-bottom: 0.5rem;
        }
        
        .tool-section {
            margin-bottom: 2rem;
            padding: 1rem;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 0.75rem;
            border: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .tool-section h4 {
            color: #e2e8f0;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        
        .tool-section p {
            color: #94a3b8;
            font-size: 0.8rem;
            line-height: 1.4;
        }
        
        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: #94a3b8;
        }
        
        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #fbbf24;
        }
        
        .empty-state h3 {
            color: #e2e8f0;
            margin-bottom: 0.5rem;
        }
        
        /* Form Enhancements */
        .input-form {
            display: flex;
            gap: 1rem;
            align-items: flex-end;
        }
        
        .input-textarea {
            flex: 1;
            padding: 1rem 1.5rem;
            border-radius: 1rem;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.3);
            color: white;
            font-family: inherit;
            font-size: 1rem;
            line-height: 1.5;
            resize: none;
            transition: all 0.3s ease;
        }
        
        .input-textarea:focus {
            outline: none;
            border-color: #fbbf24;
            box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.1);
        }
        
        .input-textarea::placeholder {
            color: #64748b;
        }
        
        .send-button {
            padding: 1rem 1.5rem;
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
            color: white;
            border: none;
            border-radius: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .send-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }
        
        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Context Block */
        .context-block {
            animation: slideInFromTop 0.5s ease-out;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(251, 191, 36, 0.3);
        }
        
        @keyframes slideInFromTop {
            from { 
                transform: translateY(-20px); 
                opacity: 0; 
            }
            to { 
                transform: translateY(0); 
                opacity: 1; 
            }
        }
        
        /* Memory Tags */
        .memory-tags .inline-block {
            transition: all 0.3s ease;
        }
        
        .memory-tags .inline-block:hover {
            transform: scale(1.05);
            opacity: 0.8;
        }
        
        /* Symbolic Tags */
        .symbolic-tag {
            transition: all 0.3s ease;
        }
        
        .symbolic-tag:hover {
            transform: translateY(-1px);
            filter: brightness(1.1);
        }
        
        /* Goal Engine */
        .goal-item {
            transition: all 0.3s ease;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }
        
        .goal-item:hover {
            border-color: rgba(16, 185, 129, 0.4);
            background-color: rgba(16, 185, 129, 0.1);
        }
        
        .progress-fill {
            transition: width 0.5s ease;
        }
        
        /* World State */
        .world-elements {
            transition: all 0.3s ease;
        }
        
        .world-elements:hover {
            background-color: rgba(59, 130, 246, 0.1);
            border-radius: 4px;
            padding: 2px;
        }
        
        /* Transformation Tracker */
        .transformation-path {
            color: #fbbf24;
            font-weight: bold;
        }
        .transformation-progress .progress-bar {
            background-color: #4b5563; /* Darker gray for progress bar */
        }
        .transformation-progress .progress-fill {
            background-color: #fbbf24; /* Yellow for progress fill */
        }
        .transformation-evidence {
            font-style: italic;
            color: #94a3b8;
        }

        /* Resolution Monitoring */
        .resolution-stage {
            color: #10b981;
            font-weight: bold;
        }
        .resolution-progress .progress-bar {
            background-color: #4b5563; /* Darker gray for progress bar */
        }
        .resolution-progress .progress-fill {
            background-color: #10b981; /* Green for progress fill */
        }
        .resolution-justification, .resolution-recommendation {
            font-style: italic;
            color: #94a3b8;
        }

        /* Cinematic Ending Overlay */
        .cinematic-ending-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
        }

        .cinematic-ending-overlay.show {
            opacity: 1;
        }

        .cinematic-content {
            max-width: 800px;
            width: 90%;
            text-align: center;
            color: #e2e8f0;
            animation: fadeInUp 1.2s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .ending-headline {
            margin-bottom: 3rem;
        }

        .ending-title {
            font-size: 3rem;
            font-weight: bold;
            color: #fbbf24;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
        }

        .ending-subtitle {
            font-size: 1.2rem;
            color: #94a3b8;
            font-style: italic;
        }

        .ending-content {
            margin-bottom: 3rem;
        }

        .ending-type-display {
            margin-bottom: 2rem;
            padding: 2rem;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 1rem;
            border: 2px solid rgba(251, 191, 36, 0.3);
        }

        .ending-type-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #fbbf24;
        }

        .ending-type-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: #e2e8f0;
        }

        .transformation-summary, .goals-recap {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 0.75rem;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .transformation-summary h3, .goals-recap h3 {
            color: #fbbf24;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .transformation-path {
            font-weight: bold;
            color: #e2e8f0;
            margin-bottom: 0.5rem;
        }

        .transformation-description {
            color: #94a3b8;
            font-style: italic;
        }

        .goals-list {
            text-align: left;
        }

        .goal-item {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background: rgba(16, 185, 129, 0.1);
            border-radius: 0.5rem;
            border-left: 3px solid #10b981;
        }

        .ending-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .epilogue-button, .new-game-button, .exit-game-button {
            padding: 1rem 2rem;
            border: none;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .epilogue-button {
            background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%);
            color: white;
        }

        .new-game-button {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .exit-game-button {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
        }

        .epilogue-button:hover, .new-game-button:hover, .exit-game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .replay-epilogue-button, .download-epilogue-button, .new-game-plus-button {
            padding: 1rem 2rem;
            border: none;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .replay-epilogue-button {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .download-epilogue-button {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
        }

        .new-game-plus-button {
            background: linear-gradient(135deg, #ec4899 0%, #be185d 100%);
            color: white;
        }

        .replay-epilogue-button:hover, .download-epilogue-button:hover, .new-game-plus-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        /* Epilogue Panel */
        .epilogue-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(15, 23, 42, 0.95);
            z-index: 1100;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.6s ease-in-out;
        }

        .epilogue-panel.show {
            opacity: 1;
        }

        .epilogue-content {
            max-width: 900px;
            width: 90%;
            max-height: 80vh;
            background: rgba(30, 41, 59, 0.9);
            border-radius: 1rem;
            border: 2px solid rgba(251, 191, 36, 0.3);
            padding: 2rem;
            overflow-y: auto;
            animation: slideInUp 0.8s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(100px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .epilogue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            padding-bottom: 1rem;
        }

        .epilogue-title {
            color: #fbbf24;
            font-size: 2rem;
            margin: 0;
        }

        .close-epilogue-btn {
            background: none;
            border: none;
            color: #94a3b8;
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-epilogue-btn:hover {
            color: #e2e8f0;
        }

        .epilogue-text {
            margin-bottom: 2rem;
            line-height: 1.8;
            color: #e2e8f0;
            font-size: 1.1rem;
        }

        .epilogue-quotes {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 0.75rem;
            border-left: 4px solid #fbbf24;
        }

        .quote-container {
            font-style: italic;
            color: #94a3b8;
            text-align: center;
        }

        .epilogue-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .print-button, .share-button, .download-button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .print-button {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
        }

        .share-button {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .download-button {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .print-button:hover, .share-button:hover, .download-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .hidden {
            display: none !important;
        }
        
        /* Responsive Design */
        @media (max-width: 640px) {
            .input-form {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .send-button {
                width: 100%;
                justify-content: center;
            }
            
            .message-content {
                max-width: 95%;
            }
        }
    </style>
</head>
<body class="text-gray-100">
    <!-- Header -->
    <div class="header">
        <div class="flex items-center justify-between max-w-6xl mx-auto">
            <div class="flex items-center">
                <div class="flex items-center">
                    <img src="/static/images/SoloHeart_logo_v1.png" alt="SoloHeart Logo" class="h-8 mr-3 object-contain">
                    <h1 class="text-xl font-bold text-yellow-400">
                        SoloHeart
                    </h1>
                </div>
                <span class="ml-4 text-sm text-gray-400">|</span>
                <span class="ml-4 text-sm" id="campaignName">Adventure</span>
            </div>
            <div class="flex items-center space-x-4">
                <button onclick="saveGame()" class="text-sm text-gray-400 hover:text-yellow-400 transition-colors">
                    <i class="fas fa-save mr-1"></i>Save
                </button>
                <button onclick="goToStart()" class="text-sm text-gray-400 hover:text-red-400 transition-colors">
                    <i class="fas fa-home mr-1"></i>Menu
                </button>
            </div>
        </div>
    </div>

    <!-- Save Indicator -->
    <div class="save-indicator" id="saveIndicator">
        <i class="fas fa-check mr-1"></i>Game Saved
    </div>

    <!-- Cinematic Ending Overlay -->
    <div id="cinematicEnding" class="cinematic-ending-overlay hidden">
        <div class="cinematic-content">
            <div class="ending-headline" id="endingHeadline">
                <h1 class="ending-title">The End of the Journey</h1>
                <div class="ending-subtitle" id="endingSubtitle">Loading...</div>
            </div>
            
            <div class="ending-content">
                <div class="ending-type-display" id="endingTypeDisplay">
                    <div class="ending-type-icon" id="endingTypeIcon"></div>
                    <div class="ending-type-text" id="endingTypeText"></div>
                </div>
                
                <div class="transformation-summary" id="transformationSummary">
                    <h3>Character Transformation</h3>
                    <div class="transformation-path" id="endingTransformationPath"></div>
                    <div class="transformation-description" id="endingTransformationDescription"></div>
                </div>
                
                <div class="goals-recap" id="goalsRecap">
                    <h3>Goals Achieved</h3>
                    <div class="goals-list" id="endingGoalsList"></div>
                </div>
            </div>
            
            <div class="ending-actions">
                <button id="revealEpilogueBtn" class="epilogue-button">
                    <i class="fas fa-scroll mr-2"></i>Reveal My Epilogue
                </button>
                <button id="replayEpilogueBtn" class="replay-epilogue-button" style="display: none;">
                    <i class="fas fa-redo mr-2"></i>Replay Epilogue
                </button>
                <button id="downloadEpilogueBtn" class="download-epilogue-button" style="display: none;">
                    <i class="fas fa-download mr-2"></i>Download Epilogue
                </button>
                <button id="newGamePlusBtn" class="new-game-plus-button">
                    <i class="fas fa-plus mr-2"></i>New Game+
                </button>
                <button id="newGameBtn" class="new-game-button">
                    <i class="fas fa-play mr-2"></i>New Game
                </button>
                <button id="exitGameBtn" class="exit-game-button">
                    <i class="fas fa-home mr-2"></i>Exit to Menu
                </button>
            </div>
        </div>
    </div>

    <!-- Epilogue Panel -->
    <div id="epiloguePanel" class="epilogue-panel hidden">
        <div class="epilogue-content">
            <div class="epilogue-header">
                <h2 class="epilogue-title" id="epilogueTitle">Epilogue</h2>
                <button id="closeEpilogueBtn" class="close-epilogue-btn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="epilogue-text" id="epilogueText">
                <p>Loading epilogue...</p>
            </div>
            
            <div class="epilogue-quotes" id="epilogueQuotes">
                <div class="quote-container" id="epilogueQuoteContainer"></div>
            </div>
            
            <div class="epilogue-actions">
                <button id="printEpilogueBtn" class="print-button">
                    <i class="fas fa-print mr-2"></i>Print
                </button>
                <button id="shareEpilogueBtn" class="share-button">
                    <i class="fas fa-share mr-2"></i>Share
                </button>
                <button id="downloadEpilogueBtn" class="download-button">
                    <i class="fas fa-download mr-2"></i>Download
                </button>
            </div>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="gameplay-layout">
        <!-- Main Game Area -->
        <div class="main-game-area">
            <!-- Game Container -->
            <div class="game-container" id="gameContainer">
                <!-- Setting Introduction (shown once) -->
                <div class="setting-introduction" id="settingIntroduction">
                    <i class="fas fa-scroll text-2xl mb-2"></i>
                    <p id="settingText">Loading your adventure...</p>
                </div>

                <!-- Game Messages -->
                <div id="messagesContainer">
                    <!-- Messages will be added here -->
                </div>

                <!-- Typing Indicator -->
                <div class="typing-indicator" id="typingIndicator">
                    <i class="fas fa-spinner fa-spin mr-2"></i>
                    The Dungeon Master is thinking...
                </div>

                <!-- Empty State -->
                <div class="empty-state" id="emptyState" style="display: none;">
                    <i class="fas fa-dragon"></i>
                    <h3>Your Adventure Awaits</h3>
                    <p>Begin your journey by describing your actions...</p>
                </div>
            </div>

            <!-- Input Container -->
            <div class="input-container">
                <div class="max-w-4xl mx-auto">
                    <form class="input-form" id="playerInputForm" onsubmit="sendAction(event)">
                        <textarea 
                            id="playerInput" 
                            placeholder="What would you like to do? Describe your actions, ask questions, or interact with the world..."
                            class="input-textarea"
                            rows="3"
                            onkeydown="handleKeyPress(event)"
                        ></textarea>
                        <button type="submit" id="sendButton" class="send-button">
                            <i class="fas fa-paper-plane"></i>
                            <span class="hidden sm:inline">Send</span>
                        </button>
                    </form>
                </div>
            </div>
        </div>

        <!-- Sidebar Tools -->
        <div class="sidebar-tools" id="sidebarTools">
            <h3>Adventure Tools</h3>
            
            <!-- Memory Viewer (Active) -->
            <div class="tool-section">
                <h4><i class="fas fa-brain mr-2"></i>Memory Viewer</h4>
                <div id="memoryPreview" class="text-xs text-gray-300 mb-2">
                    <div class="memory-stats mb-2">
                        <span class="text-yellow-400">Loading memories...</span>
                    </div>
                    <div class="memory-tags mb-2">
                        <div class="emotional-tags"></div>
                        <div class="thematic-tags"></div>
                    </div>
                    <div class="recent-memories text-xs text-gray-400 max-h-32 overflow-y-auto">
                        <p>No memories available yet.</p>
                    </div>
                </div>
                <button onclick="refreshMemoryContext()" class="text-xs text-yellow-400 hover:text-yellow-300 mt-2">
                    <i class="fas fa-sync-alt mr-1"></i>Refresh
                </button>
            </div>
            
            <!-- Character Stats (Active) -->
            <div class="tool-section">
                <h4><i class="fas fa-user mr-2"></i>Character Stats</h4>
                <div id="characterStats" class="text-xs text-gray-300 mb-2">
                    <div class="stat-row flex justify-between mb-1">
                        <span>HP:</span>
                        <span id="currentHP">--</span>
                    </div>
                    <div class="stat-row flex justify-between mb-1">
                        <span>AC:</span>
                        <span id="currentAC">--</span>
                    </div>
                    <div class="stat-row flex justify-between mb-1">
                        <span>Level:</span>
                        <span id="currentLevel">--</span>
                    </div>
                    <div class="stat-row flex justify-between mb-1">
                        <span>XP:</span>
                        <span id="currentXP">--</span>
                    </div>
                </div>
                <button onclick="refreshCharacterStats()" class="text-xs text-yellow-400 hover:text-yellow-300 mt-2">
                    <i class="fas fa-chart-bar mr-1"></i>Update Stats
                </button>
            </div>
            
            <!-- World Map (Placeholder) -->
            <div class="tool-section">
                <h4><i class="fas fa-map mr-2"></i>World Map</h4>
                <p>Explore the world map and track your journey.</p>
                <button class="text-xs text-yellow-400 hover:text-yellow-300 mt-2">
                    <i class="fas fa-map-marked-alt mr-1"></i>View Map
                </button>
            </div>
            
            <!-- Quest Log (Placeholder) -->
            <div class="tool-section">
                <h4><i class="fas fa-scroll mr-2"></i>Quest Log</h4>
                <p>Track your current quests and objectives.</p>
                <button class="text-xs text-yellow-400 hover:text-yellow-300 mt-2">
                    <i class="fas fa-list-check mr-1"></i>View Quests
                </button>
            </div>
            
            <!-- Symbolic Tags -->
            <div class="tool-section">
                <h4><i class="fas fa-magic mr-2"></i>Symbolic Tags</h4>
                <div id="symbolicTags" class="text-xs text-gray-300 mb-2">
                    <div class="symbolic-stats mb-2">
                        <span class="text-purple-400">Loading symbols...</span>
                    </div>
                    <div class="symbolic-tags-container max-h-32 overflow-y-auto">
                        <p class="text-gray-400">No symbolic elements detected yet.</p>
                    </div>
                </div>
                <button onclick="refreshSymbolicTags()" class="text-xs text-purple-400 hover:text-purple-300 mt-2">
                    <i class="fas fa-sync-alt mr-1"></i>Refresh
                </button>
            </div>
            
            <!-- Goal Engine -->
            <div class="tool-section">
                <h4><i class="fas fa-bullseye mr-2"></i>Goal Engine</h4>
                <div id="goalEngine" class="text-xs text-gray-300 mb-2">
                    <div class="goal-stats mb-2">
                        <span class="text-green-400">Analyzing goals...</span>
                    </div>
                    <div class="active-goals max-h-40 overflow-y-auto">
                        <p class="text-gray-400">No active goals detected yet.</p>
                    </div>
                </div>
                <button onclick="refreshGoalEngine()" class="text-xs text-green-400 hover:text-green-300 mt-2">
                    <i class="fas fa-chart-line mr-1"></i>Analyze
                </button>
            </div>
            
            <!-- World State -->
            <div class="tool-section">
                <h4><i class="fas fa-globe mr-2"></i>World State</h4>
                <div id="worldState" class="text-xs text-gray-300 mb-2">
                    <div class="world-stats mb-2">
                        <span class="text-blue-400">Loading world...</span>
                    </div>
                    <div class="world-elements max-h-40 overflow-y-auto">
                        <div class="location-info mb-2">
                            <span class="text-blue-400 font-semibold">Location:</span>
                            <span class="text-gray-400">Unknown</span>
                        </div>
                        <div class="items-info mb-2">
                            <span class="text-blue-400 font-semibold">Items:</span>
                            <span class="text-gray-400">None</span>
                        </div>
                        <div class="npcs-info mb-2">
                            <span class="text-blue-400 font-semibold">NPCs:</span>
                            <span class="text-gray-400">None met</span>
                        </div>
                        <div class="story-flags-info mb-2">
                            <span class="text-blue-400 font-semibold">Story:</span>
                            <span class="text-gray-400">No flags</span>
                        </div>
                    </div>
                </div>
                <button onclick="refreshWorldState()" class="text-xs text-blue-400 hover:text-blue-300 mt-2">
                    <i class="fas fa-sync-alt mr-1"></i>Refresh
                </button>
            </div>
            
            <!-- Transformation Tracker -->
            <div class="tool-section">
                <h4><i class="fas fa-random mr-2"></i>Transformation Tracker</h4>
                <div id="transformationTracker" class="text-xs text-gray-300 mb-2">
                    <div class="transformation-path mb-1 text-yellow-400 font-semibold">Detecting transformation...</div>
                    <div class="transformation-progress mb-1">
                        <div class="progress-bar bg-gray-700 rounded-full h-1">
                            <div class="progress-fill h-1 rounded-full bg-yellow-400" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="transformation-evidence mb-1 text-gray-400"></div>
                    <button onclick="toggleTransformationTimeline()" class="text-xs text-yellow-400 hover:text-yellow-300 mt-2">
                        <i class="fas fa-history mr-1"></i>Timeline
                    </button>
                    <div id="transformationTimeline" class="hidden mt-2 text-xs text-gray-400"></div>
                </div>
                <button onclick="refreshTransformation()" class="text-xs text-yellow-400 hover:text-yellow-300 mt-2">
                    <i class="fas fa-sync-alt mr-1"></i>Refresh
                </button>
            </div>
            
            <!-- Resolution Monitoring -->
            <div class="tool-section">
                <h4><i class="fas fa-flag-checkered mr-2"></i>Resolution Monitor</h4>
                <div id="resolutionMonitor" class="text-xs text-gray-300 mb-2">
                    <div class="resolution-stage mb-1 text-green-400 font-semibold">Detecting resolution...</div>
                    <div class="resolution-progress mb-1">
                        <div class="progress-bar bg-gray-700 rounded-full h-1">
                            <div class="progress-fill h-1 rounded-full bg-green-400" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="resolution-justification mb-1 text-gray-400"></div>
                    <div class="resolution-recommendation mb-1 text-gray-400"></div>
                </div>
                <button onclick="refreshResolution()" class="text-xs text-green-400 hover:text-green-300 mt-2">
                    <i class="fas fa-sync-alt mr-1"></i>Refresh
                </button>
            </div>
            
            <!-- Confrontation Log (React Hydration Mount) -->
            <div class="tool-section">
                <h4><i class="fas fa-exclamation-triangle mr-2"></i>Confrontation Log</h4>
                <!-- React hydration mount point -->
                <div id="confrontation-log-root" data-identity-scope-id="{{ identity_scope_id }}"></div>
            </div>
            
            <!-- Session Manager -->
            <div class="tool-section">
                <h4><i class="fas fa-folder mr-2"></i>Session Manager</h4>
                <div id="sessionManager" class="text-xs text-gray-300 mb-2">
                    <div class="session-stats mb-2">
                        <span class="text-cyan-400">Loading sessions...</span>
                    </div>
                    <div class="session-list max-h-40 overflow-y-auto">
                        <p class="text-gray-400">No sessions available.</p>
                    </div>
                </div>
                <div class="flex gap-1 mt-2">
                    <button onclick="loadSessions()" class="text-xs text-cyan-400 hover:text-cyan-300">
                        <i class="fas fa-sync-alt mr-1"></i>Refresh
                    </button>
                    <button onclick="showNewSessionModal()" class="text-xs text-green-400 hover:text-green-300">
                        <i class="fas fa-plus mr-1"></i>New
                    </button>
                </div>
            </div>
            
            <!-- Dev Context Toggle -->
            <div class="tool-section">
                <h4><i class="fas fa-code mr-2"></i>Developer Tools</h4>
                <div class="flex items-center justify-between">
                    <span class="text-xs text-gray-400">Show Context</span>
                    <button id="contextToggle" onclick="toggleContextDisplay()" class="text-xs text-yellow-400 hover:text-yellow-300">
                        <i class="fas fa-eye-slash mr-1"></i>Hidden
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- React 18 UMD CDN (Required before hydration script) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom-client.production.min.js"></script>

    <!-- Hydration script for Confrontation Log -->
    <script>
      const identityScopeId = "{{ identity_scope_id }}"; // Injected from Flask backend
      // Attach to root element for React hydration
      const rootEl = document.getElementById('confrontation-log-root');
      if (rootEl) {
        rootEl.setAttribute('data-identity-scope-id', identityScopeId);
      }
    </script>
    <script src="{{ url_for('static', filename='js/confrontation-log-client.js') }}"></script>

    <script>
        // Global state
        let isProcessing = false;
        let retryCount = 0;
        const maxRetries = 3;
        let connectionError = false;

        // Initialize the game
        document.addEventListener('DOMContentLoaded', function() {
            loadGameState();
            setupEventListeners();
        });

        function setupEventListeners() {
            // Auto-resize textarea
            const textarea = document.getElementById('playerInput');
            textarea.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 120) + 'px';
            });

            // Auto-scroll to bottom when new messages are added
            const gameContainer = document.getElementById('gameContainer');
            const observer = new MutationObserver(function() {
                gameContainer.scrollTop = gameContainer.scrollHeight;
            });
            observer.observe(gameContainer, { childList: true, subtree: true });
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendAction();
            }
        }

        async function sendAction(event) {
            if (event) event.preventDefault();
            
            const input = document.getElementById('playerInput');
            const playerInput = input.value.trim();
            
            if (!playerInput || isProcessing) return;
            
            // Add player message to chat
            addMessage('player', playerInput);
            input.value = '';
            input.style.height = 'auto';
            
            // Show typing indicator
            showTypingIndicator();
            isProcessing = true;
            
            try {
                const response = await fetch('/api/game/action', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ input: playerInput })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Add DM response
                    addMessage('dm', data.dm_response);
                    connectionError = false;
                    retryCount = 0;
                } else {
                    throw new Error(data.message || 'Failed to process action');
                }
                
            } catch (error) {
                console.error('Error sending action:', error);
                handleError(error.message);
            } finally {
                hideTypingIndicator();
                isProcessing = false;
            }
        }

        function addMessage(role, content) {
            const messagesContainer = document.getElementById('messagesContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            
            if (role === 'dm') {
                // Render markdown for DM messages
                messageContent.innerHTML = marked.parse(content);
                messageContent.classList.add('markdown-content');
            } else {
                // Plain text for player messages
                messageContent.textContent = content;
            }
            
            messageDiv.appendChild(messageContent);
            messagesContainer.appendChild(messageDiv);
            
            // Hide empty state if it's showing
            document.getElementById('emptyState').style.display = 'none';
            
            // Auto-scroll to bottom
            setTimeout(() => {
                const gameContainer = document.getElementById('gameContainer');
                gameContainer.scrollTop = gameContainer.scrollHeight;
            }, 100);
        }

        function showTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            indicator.classList.add('show');
        }

        function hideTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            indicator.classList.remove('show');
        }

        function handleError(message) {
            const gameContainer = document.getElementById('gameContainer');
            
            // Remove existing error banners
            const existingErrors = gameContainer.querySelectorAll('.error-banner');
            existingErrors.forEach(error => error.remove());
            
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-banner';
            errorDiv.innerHTML = `
                <i class="fas fa-exclamation-triangle mr-2"></i>
                <strong>Connection Error:</strong> ${message}
                <br>
                <button class="retry-button" onclick="retryConnection()">
                    <i class="fas fa-redo mr-1"></i>Retry
                </button>
            `;
            
            gameContainer.appendChild(errorDiv);
            connectionError = true;
        }

        async function retryConnection() {
            if (retryCount >= maxRetries) {
                alert('Maximum retry attempts reached. Please refresh the page.');
                return;
            }
            
            retryCount++;
            console.log(`Retry attempt ${retryCount}/${maxRetries}`);
            
            // Remove error banner
            const errorBanner = document.querySelector('.error-banner');
            if (errorBanner) {
                errorBanner.remove();
            }
            
            // Show typing indicator
            showTypingIndicator();
            
            try {
                // Test connection
                const response = await fetch('/api/health', { timeout: 5000 });
                if (response.ok) {
                    connectionError = false;
                    retryCount = 0;
                    hideTypingIndicator();
                    console.log('Connection restored');
                } else {
                    throw new Error('Health check failed');
                }
            } catch (error) {
                hideTypingIndicator();
                handleError('Connection still unavailable. Please check your network.');
            }
        }

        async function loadGameState() {
            try {
                const response = await fetch('/api/game/current');
                const data = await response.json();
                
                if (data.success && data.campaign) {
                    // Load campaign name
                    const campaignName = document.getElementById('campaignName');
                    campaignName.textContent = data.campaign.name || 'Adventure';
                    
                    // Load campaign recap
                    const recapResponse = await fetch('/api/game/recap');
                    const recapData = await recapResponse.json();
                    
                    if (recapData.success && recapData.recap) {
                        addMessage('dm', recapData.recap);
                    } else {
                        // Show empty state
                        document.getElementById('emptyState').style.display = 'block';
                    }
                } else {
                    // Show empty state
                    document.getElementById('emptyState').style.display = 'block';
                }
                
            } catch (error) {
                console.error('Error loading game state:', error);
                document.getElementById('emptyState').style.display = 'block';
            }
        }

        async function saveGame() {
            try {
                const response = await fetch('/api/game/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showSaveIndicator();
                } else {
                    console.error('Save failed:', data.message);
                }
                
            } catch (error) {
                console.error('Error saving game:', error);
            }
        }

        function showSaveIndicator() {
            const indicator = document.getElementById('saveIndicator');
            indicator.classList.add('show');
            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        function goToStart() {
            window.location.href = '/';
        }

        // Auto-retry on connection restore
        setInterval(() => {
            if (connectionError && retryCount < maxRetries) {
                retryConnection();
            }
        }, 10000); // Check every 10 seconds

        // Memory and Context Functions
        let contextDisplayVisible = false;
        let lastMemoryContext = null;

        async function refreshMemoryContext() {
            try {
                const response = await fetch('/api/memory/context');
                const data = await response.json();
                
                if (data.success && data.memory_context) {
                    updateMemoryDisplay(data.memory_context);
                    lastMemoryContext = data.memory_context;
                } else {
                    updateMemoryDisplay({
                        recent_memories: "No memories available",
                        memory_stats: {'total_memories': 0, 'recent_memories': 0},
                        emotional_tags: [],
                        thematic_tags: [],
                        importance_levels: []
                    });
                }
            } catch (error) {
                console.error('Error refreshing memory context:', error);
                updateMemoryDisplay({
                    recent_memories: "Error loading memories",
                    memory_stats: {'total_memories': 0, 'recent_memories': 0},
                    emotional_tags: [],
                    thematic_tags: [],
                    importance_levels: []
                });
            }
        }

        function updateMemoryDisplay(memoryContext) {
            const memoryPreview = document.getElementById('memoryPreview');
            
            // Update memory stats
            const statsElement = memoryPreview.querySelector('.memory-stats');
            statsElement.innerHTML = `
                <span class="text-yellow-400">
                    ${memoryContext.memory_stats.total_memories || 0} total, 
                    ${memoryContext.memory_stats.recent_memories || 0} recent
                </span>
            `;
            
            // Update emotional tags
            const emotionalTags = memoryPreview.querySelector('.emotional-tags');
            if (memoryContext.emotional_tags && memoryContext.emotional_tags.length > 0) {
                emotionalTags.innerHTML = `
                    <div class="mb-1">
                        <span class="text-red-400 text-xs">Emotional:</span>
                        ${memoryContext.emotional_tags.slice(0, 3).map(tag => 
                            `<span class="inline-block bg-red-900 bg-opacity-50 px-1 rounded text-xs mr-1">${tag}</span>`
                        ).join('')}
                    </div>
                `;
            } else {
                emotionalTags.innerHTML = '';
            }
            
            // Update thematic tags
            const thematicTags = memoryPreview.querySelector('.thematic-tags');
            if (memoryContext.thematic_tags && memoryContext.thematic_tags.length > 0) {
                thematicTags.innerHTML = `
                    <div class="mb-1">
                        <span class="text-blue-400 text-xs">Thematic:</span>
                        ${memoryContext.thematic_tags.slice(0, 3).map(tag => 
                            `<span class="inline-block bg-blue-900 bg-opacity-50 px-1 rounded text-xs mr-1">${tag}</span>`
                        ).join('')}
                    </div>
                `;
            } else {
                thematicTags.innerHTML = '';
            }
            
            // Update recent memories
            const recentMemories = memoryPreview.querySelector('.recent-memories');
            if (memoryContext.recent_memories && memoryContext.recent_memories !== "No memories available") {
                const memoryLines = memoryContext.recent_memories.split('\n').slice(0, 5);
                recentMemories.innerHTML = memoryLines.map(line => 
                    `<p class="mb-1 text-gray-400">${line}</p>`
                ).join('');
            } else {
                recentMemories.innerHTML = '<p class="text-gray-400">No memories available yet.</p>';
            }
        }

        async function refreshCharacterStats() {
            try {
                const response = await fetch('/api/game/current');
                const data = await response.json();
                
                if (data.success && data.campaign && data.campaign.active_character) {
                    const character = data.campaign.active_character;
                    
                    document.getElementById('currentHP').textContent = `${character.hit_points || 10}/${character.hit_points || 10}`;
                    document.getElementById('currentAC').textContent = character.armor_class || 10;
                    document.getElementById('currentLevel').textContent = character.level || 1;
                    document.getElementById('currentXP').textContent = character.experience || 0;
                }
            } catch (error) {
                console.error('Error refreshing character stats:', error);
            }
        }

        function toggleContextDisplay() {
            const toggle = document.getElementById('contextToggle');
            const gameContainer = document.getElementById('gameContainer');
            
            contextDisplayVisible = !contextDisplayVisible;
            
            if (contextDisplayVisible) {
                toggle.innerHTML = '<i class="fas fa-eye mr-1"></i>Visible';
                showContextBlock();
            } else {
                toggle.innerHTML = '<i class="fas fa-eye-slash mr-1"></i>Hidden';
                hideContextBlock();
            }
        }

        function showContextBlock() {
            // Remove existing context block
            const existingContext = document.querySelector('.context-block');
            if (existingContext) {
                existingContext.remove();
            }
            
            // Create context block
            const contextBlock = document.createElement('div');
            contextBlock.className = 'context-block bg-gray-800 bg-opacity-50 border border-yellow-400 border-opacity-30 rounded-lg p-4 mb-4 text-xs text-gray-300';
            contextBlock.innerHTML = `
                <div class="flex items-center justify-between mb-2">
                    <span class="text-yellow-400 font-semibold">Developer Context</span>
                    <button onclick="hideContextBlock()" class="text-gray-400 hover:text-white">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="context-content">
                    <div class="mb-2">
                        <span class="text-blue-400">Memory Context:</span>
                        <div class="ml-2 text-gray-400">${lastMemoryContext ? JSON.stringify(lastMemoryContext, null, 2) : 'No memory context available'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-purple-400">Symbolic Tags:</span>
                        <div class="ml-2 text-gray-400">${lastSymbolicTags ? JSON.stringify(lastSymbolicTags, null, 2) : 'No symbolic tags available'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-green-400">Inferred Goals:</span>
                        <div class="ml-2 text-gray-400">${lastInferredGoals ? JSON.stringify(lastInferredGoals, null, 2) : 'No goals available'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-blue-400">World State:</span>
                        <div class="ml-2 text-gray-400">${lastWorldState ? JSON.stringify(lastWorldState, null, 2) : 'No world state available'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-yellow-400">Transformation:</span>
                        <div class="ml-2 text-gray-400">${lastTransformation ? JSON.stringify(lastTransformation, null, 2) : 'No transformation available'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-green-400">Resolution:</span>
                        <div class="ml-2 text-gray-400">${lastResolution ? JSON.stringify(lastResolution, null, 2) : 'No resolution available'}</div>
                    </div>
                </div>
            `;
            
            // Insert at the top of game container
            const gameContainer = document.getElementById('gameContainer');
            const settingIntro = document.getElementById('settingIntroduction');
            if (settingIntro) {
                gameContainer.insertBefore(contextBlock, settingIntro.nextSibling);
            } else {
                gameContainer.insertBefore(contextBlock, gameContainer.firstChild);
            }
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (contextDisplayVisible) {
                    hideContextBlock();
                }
            }, 10000);
        }

        function hideContextBlock() {
            const contextBlock = document.querySelector('.context-block');
            if (contextBlock) {
                contextBlock.remove();
            }
            contextDisplayVisible = false;
            const toggle = document.getElementById('contextToggle');
            toggle.innerHTML = '<i class="fas fa-eye-slash mr-1"></i>Hidden';
        }

        // Enhanced sendAction function with memory, symbolic, and goal integration
        async function sendAction(event) {
            if (event) event.preventDefault();
            
            const input = document.getElementById('playerInput');
            const playerInput = input.value.trim();
            
            if (!playerInput || isProcessing) return;
            
            // Add player message to chat
            addMessage('player', playerInput);
            input.value = '';
            input.style.height = 'auto';
            
            // Show typing indicator
            showTypingIndicator();
            isProcessing = true;
            
            try {
                // Refresh memory context before sending action
                await refreshMemoryContext();
                
                const response = await fetch('/api/game/action', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ input: playerInput })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Add DM response
                    addMessage('dm', data.dm_response);
                    connectionError = false;
                    retryCount = 0;
                    
                    // Refresh all context after action
                    await Promise.all([
                        refreshCharacterStats(),
                        refreshSymbolicTags(),
                        refreshGoalEngine(),
                        refreshWorldState()
                    ]);
                } else {
                    throw new Error(data.message || 'Failed to process action');
                }
                
            } catch (error) {
                console.error('Error sending action:', error);
                handleError(error.message);
            } finally {
                hideTypingIndicator();
                isProcessing = false;
            }
        }

        // Initialize memory and stats on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadGameState();
            setupEventListeners();
            
            // Load initial memory context and character stats
            setTimeout(() => {
                refreshMemoryContext();
                refreshCharacterStats();
                refreshSymbolicTags();
                refreshGoalEngine();
                refreshWorldState();
            }, 1000);
        });

        // Symbolic Tags Functions
        let lastSymbolicTags = null;

        async function refreshSymbolicTags() {
            try {
                // Get recent narrative text from messages
                const messages = document.querySelectorAll('.message.dm .message-content');
                let narrativeText = "";
                
                // Combine last 3 DM messages
                for (let i = Math.max(0, messages.length - 3); i < messages.length; i++) {
                    narrativeText += messages[i].textContent + " ";
                }
                
                if (!narrativeText.trim()) {
                    updateSymbolicDisplay({
                        symbolic_tags: [],
                        stats: {'total_symbols': 0, 'active_symbols': 0}
                    });
                    return;
                }
                
                const response = await fetch('/api/symbolic/tags', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        narrative_text: narrativeText,
                        memory_context: lastMemoryContext || {},
                        character_stats: {}
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.symbolic_tags) {
                    updateSymbolicDisplay({
                        symbolic_tags: data.symbolic_tags,
                        stats: {'total_symbols': data.symbolic_tags.length, 'active_symbols': data.symbolic_tags.length}
                    });
                    lastSymbolicTags = data.symbolic_tags;
                } else {
                    updateSymbolicDisplay({
                        symbolic_tags: [],
                        stats: {'total_symbols': 0, 'active_symbols': 0}
                    });
                }
            } catch (error) {
                console.error('Error refreshing symbolic tags:', error);
                updateSymbolicDisplay({
                    symbolic_tags: [],
                    stats: {'total_symbols': 0, 'active_symbols': 0}
                });
            }
        }

        function updateSymbolicDisplay(symbolicData) {
            const symbolicTags = document.getElementById('symbolicTags');
            
            // Update stats
            const statsElement = symbolicTags.querySelector('.symbolic-stats');
            statsElement.innerHTML = `
                <span class="text-purple-400">
                    ${symbolicData.stats.total_symbols || 0} symbols detected
                </span>
            `;
            
            // Update symbolic tags
            const tagsContainer = symbolicTags.querySelector('.symbolic-tags-container');
            if (symbolicData.symbolic_tags && symbolicData.symbolic_tags.length > 0) {
                const tagElements = symbolicData.symbolic_tags.map(tag => {
                    const color = tag.color || '#8b5cf6';
                    const tooltip = tag.tooltip || `${tag.type}: ${tag.symbol}`;
                    return `
                        <div class="symbolic-tag mb-1" title="${tooltip}">
                            <span class="inline-block px-2 py-1 rounded text-xs mr-1" 
                                  style="background-color: ${color}; color: white;">
                                ${tag.symbol}
                            </span>
                            <span class="text-gray-400 text-xs">${tag.type}</span>
                        </div>
                    `;
                }).join('');
                tagsContainer.innerHTML = tagElements;
            } else {
                tagsContainer.innerHTML = '<p class="text-gray-400">No symbolic elements detected yet.</p>';
            }
        }

        // World State Functions
        let lastWorldState = null;

        async function refreshWorldState() {
            try {
                const response = await fetch('/api/world/state', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success && data.world_state) {
                    updateWorldStateDisplay(data.world_state);
                    lastWorldState = data.world_state;
                } else {
                    updateWorldStateDisplay({
                        current_location: 'Unknown',
                        items: [],
                        npc_flags: {},
                        story_flags: {},
                        discovered_locations: [],
                        met_characters: [],
                        acquired_items: []
                    });
                }
            } catch (error) {
                console.error('Error refreshing world state:', error);
                updateWorldStateDisplay({
                    current_location: 'Unknown',
                    items: [],
                    npc_flags: {},
                    story_flags: {},
                    discovered_locations: [],
                    met_characters: [],
                    acquired_items: []
                });
            }
        }

        function updateWorldStateDisplay(worldState) {
            const worldStateElement = document.getElementById('worldState');
            
            // Update stats
            const statsElement = worldStateElement.querySelector('.world-stats');
            const locationCount = worldState.discovered_locations ? worldState.discovered_locations.length : 0;
            const itemCount = worldState.items ? worldState.items.length : 0;
            const npcCount = worldState.met_characters ? worldState.met_characters.length : 0;
            
            statsElement.innerHTML = `
                <span class="text-blue-400">
                    ${locationCount} locations, ${itemCount} items, ${npcCount} NPCs
                </span>
            `;
            
            // Update location
            const locationElement = worldStateElement.querySelector('.location-info');
            locationElement.innerHTML = `
                <span class="text-blue-400 font-semibold">Location:</span>
                <span class="text-gray-400">${worldState.current_location || 'Unknown'}</span>
            `;
            
            // Update items
            const itemsElement = worldStateElement.querySelector('.items-info');
            if (worldState.items && worldState.items.length > 0) {
                itemsElement.innerHTML = `
                    <span class="text-blue-400 font-semibold">Items:</span>
                    <span class="text-gray-400">${worldState.items.join(', ')}</span>
                `;
            } else {
                itemsElement.innerHTML = `
                    <span class="text-blue-400 font-semibold">Items:</span>
                    <span class="text-gray-400">None</span>
                `;
            }
            
            // Update NPCs
            const npcsElement = worldStateElement.querySelector('.npcs-info');
            if (worldState.npc_flags && Object.keys(worldState.npc_flags).length > 0) {
                const npcList = Object.entries(worldState.npc_flags).map(([npc, status]) => 
                    `${npc} (${status})`
                ).join(', ');
                npcsElement.innerHTML = `
                    <span class="text-blue-400 font-semibold">NPCs:</span>
                    <span class="text-gray-400">${npcList}</span>
                `;
            } else {
                npcsElement.innerHTML = `
                    <span class="text-blue-400 font-semibold">NPCs:</span>
                    <span class="text-gray-400">None met</span>
                `;
            }
            
            // Update story flags
            const storyFlagsElement = worldStateElement.querySelector('.story-flags-info');
            if (worldState.story_flags && Object.keys(worldState.story_flags).length > 0) {
                const flagList = Object.entries(worldState.story_flags).map(([flag, value]) => 
                    `${flag}: ${value}`
                ).join(', ');
                storyFlagsElement.innerHTML = `
                    <span class="text-blue-400 font-semibold">Story:</span>
                    <span class="text-gray-400">${flagList}</span>
                `;
            } else {
                storyFlagsElement.innerHTML = `
                    <span class="text-blue-400 font-semibold">Story:</span>
                    <span class="text-gray-400">No flags</span>
                `;
            }
        }

        // Goal Engine Functions
        let lastInferredGoals = null;

        async function refreshGoalEngine() {
            try {
                // Get session history from messages
                const messages = document.querySelectorAll('.message');
                const sessionHistory = [];
                
                messages.forEach(msg => {
                    const isPlayer = msg.classList.contains('player');
                    const content = msg.querySelector('.message-content').textContent;
                    sessionHistory.push({
                        role: isPlayer ? 'user' : 'assistant',
                        content: content
                    });
                });
                
                const response = await fetch('/api/goal/infer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_history: sessionHistory,
                        memory_context: lastMemoryContext || {},
                        current_turn: {input: ''}
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.inferred_goals) {
                    updateGoalDisplay({
                        inferred_goals: data.inferred_goals,
                        stats: {'total_goals': data.inferred_goals.length, 'active_goals': data.inferred_goals.length}
                    });
                    lastInferredGoals = data.inferred_goals;
                } else {
                    updateGoalDisplay({
                        inferred_goals: [],
                        stats: {'total_goals': 0, 'active_goals': 0}
                    });
                }
            } catch (error) {
                console.error('Error refreshing goal engine:', error);
                updateGoalDisplay({
                    inferred_goals: [],
                    stats: {'total_goals': 0, 'active_goals': 0}
                });
            }
        }

        function updateGoalDisplay(goalData) {
            const goalEngine = document.getElementById('goalEngine');
            
            // Update stats
            const statsElement = goalEngine.querySelector('.goal-stats');
            statsElement.innerHTML = `
                <span class="text-green-400">
                    ${goalData.stats.active_goals || 0} active goals
                </span>
            `;
            
            // Update active goals
            const goalsContainer = goalEngine.querySelector('.active-goals');
            if (goalData.inferred_goals && goalData.inferred_goals.length > 0) {
                const goalElements = goalData.inferred_goals.map(goal => {
                    const confidence = goal.confidence || 0;
                    const progress = goal.progress || 0;
                    const color = goal.color || '#10b981';
                    
                    return `
                        <div class="goal-item mb-2 p-2 bg-gray-800 bg-opacity-50 rounded">
                            <div class="flex items-center justify-between mb-1">
                                <span class="text-xs font-semibold" style="color: ${color};">${goal.type}</span>
                                <span class="text-xs text-gray-400">${(confidence * 100).toFixed(0)}%</span>
                            </div>
                            <div class="progress-bar bg-gray-700 rounded-full h-1 mb-1">
                                <div class="progress-fill h-1 rounded-full" 
                                     style="background-color: ${color}; width: ${progress * 100}%;"></div>
                            </div>
                            <p class="text-xs text-gray-400">${goal.justification}</p>
                        </div>
                    `;
                }).join('');
                goalsContainer.innerHTML = goalElements;
            } else {
                goalsContainer.innerHTML = '<p class="text-gray-400">No active goals detected yet.</p>';
            }
        }

        let lastTransformation = null;
        let lastResolution = null;
        let transformationTimeline = [];

        async function refreshTransformation() {
            try {
                // Get session history from messages
                const messages = document.querySelectorAll('.message');
                const narrativeHistory = [];
                messages.forEach(msg => {
                    const isPlayer = msg.classList.contains('player');
                    const content = msg.querySelector('.message-content').textContent;
                    narrativeHistory.push({
                        role: isPlayer ? 'user' : 'assistant',
                        content: content
                    });
                });
                // Get recent symbolic tags
                const symbolicTags = lastSymbolicTags || [];
                // Get character stats (optional, not used here)
                const characterStats = {};
                const response = await fetch('/api/transformation/infer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        narrative_history: narrativeHistory,
                        symbolic_tags: symbolicTags,
                        character_stats: characterStats
                    })
                });
                const data = await response.json();
                if (data.success && data.transformation) {
                    updateTransformationDisplay(data.transformation);
                    lastTransformation = data.transformation;
                    // Track timeline
                    if (data.transformation.transformation_type && data.transformation.transformation_type !== 'Unknown') {
                        transformationTimeline.push({
                            type: data.transformation.transformation_type,
                            confidence: data.transformation.confidence_score,
                            time: new Date().toLocaleTimeString()
                        });
                    }
                } else {
                    updateTransformationDisplay({});
                }
            } catch (error) {
                console.error('Error refreshing transformation:', error);
                updateTransformationDisplay({});
            }
        }

        function updateTransformationDisplay(transformation) {
            const tracker = document.getElementById('transformationTracker');
            const path = tracker.querySelector('.transformation-path');
            const progress = tracker.querySelector('.progress-fill');
            const evidence = tracker.querySelector('.transformation-evidence');
            if (transformation && transformation.transformation_type && transformation.transformation_type !== 'Unknown') {
                path.textContent = transformation.transformation_type + (transformation.archetypal_shift ? ` (${transformation.archetypal_shift})` : '');
                progress.style.width = `${Math.round((transformation.confidence_score || 0) * 100)}%`;
                evidence.innerHTML = (transformation.evidence_snippets && transformation.evidence_snippets.length > 0)
                    ? transformation.evidence_snippets.map(snip => `<div class='mb-1'>&ldquo;${snip}&rdquo;</div>`).join('')
                    : '<span class="text-gray-500">No evidence found.</span>';
            } else {
                path.textContent = 'No transformation detected yet.';
                progress.style.width = '0%';
                evidence.innerHTML = '';
            }
        }

        function toggleTransformationTimeline() {
            const timelineDiv = document.getElementById('transformationTimeline');
            if (timelineDiv.classList.contains('hidden')) {
                timelineDiv.classList.remove('hidden');
                if (transformationTimeline.length > 0) {
                    timelineDiv.innerHTML = transformationTimeline.map(t =>
                        `<div class='mb-1'><span class='text-yellow-400'>${t.type}</span> <span class='text-gray-400'>(${Math.round((t.confidence || 0) * 100)}%)</span> <span class='text-gray-500'>@${t.time}</span></div>`
                    ).join('');
                } else {
                    timelineDiv.innerHTML = '<span class="text-gray-500">No past transformations.</span>';
                }
            } else {
                timelineDiv.classList.add('hidden');
            }
        }

        async function refreshResolution() {
            try {
                // Get goals, world state, memory, transformations
                const goals = lastInferredGoals || [];
                const worldState = lastWorldState || {};
                const memoryContext = lastMemoryContext || {};
                const transformations = lastTransformation ? [lastTransformation] : [];
                const response = await fetch('/api/resolution/monitor', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        goals: goals,
                        world_state: worldState,
                        memory_context: memoryContext,
                        transformations: transformations
                    })
                });
                const data = await response.json();
                if (data.success && data.resolution) {
                    updateResolutionDisplay(data.resolution);
                    lastResolution = data.resolution;
                } else {
                    updateResolutionDisplay({});
                }
            } catch (error) {
                console.error('Error refreshing resolution:', error);
                updateResolutionDisplay({});
            }
        }

        function updateResolutionDisplay(resolution) {
            const monitor = document.getElementById('resolutionMonitor');
            const stage = monitor.querySelector('.resolution-stage');
            const progress = monitor.querySelector('.progress-fill');
            const justification = monitor.querySelector('.resolution-justification');
            const recommendation = monitor.querySelector('.resolution-recommendation');
            if (resolution && resolution.resolution_state) {
                stage.textContent = `Stage: ${resolution.resolution_state.charAt(0).toUpperCase() + resolution.resolution_state.slice(1)}`;
                progress.style.width = `${Math.round((resolution.progress || 0) * 100)}%`;
                justification.textContent = resolution.justification || '';
                recommendation.textContent = resolution.recommendation ? `Recommendation: ${resolution.recommendation}` : '';
            } else {
                stage.textContent = 'No resolution detected yet.';
                progress.style.width = '0%';
                justification.textContent = '';
                recommendation.textContent = '';
            }
        }

        async function refreshConfrontationLog() {
            try {
                const response = await fetch('/api/confrontations');
                const data = await response.json();
                
                if (data.success) {
                    updateConfrontationDisplay(data.confrontations || [], data.total_count || 0);
                } else {
                    updateConfrontationDisplay([], 0);
                }
            } catch (error) {
                console.error('Error refreshing confrontation log:', error);
                updateConfrontationDisplay([], 0);
            }
        }

        function updateConfrontationDisplay(confrontations, totalCount) {
            const logContainer = document.getElementById('confrontationLog');
            const stats = logContainer.querySelector('.confrontation-stats');
            const list = logContainer.querySelector('.confrontation-list');
            
            if (totalCount > 0) {
                stats.innerHTML = `<span class="text-orange-400">${totalCount} confrontation${totalCount !== 1 ? 's' : ''} logged</span>`;
                
                list.innerHTML = confrontations.map(confrontation => `
                    <div class="confrontation-item mb-2 p-2 bg-gray-800 rounded border-l-2 border-orange-400">
                        <div class="confrontation-header flex justify-between items-center mb-1">
                            <span class="text-orange-300 font-semibold text-xs">${confrontation.confrontation_type || 'Unknown'}</span>
                            <span class="text-gray-400 text-xs">${new Date(confrontation.timestamp).toLocaleTimeString()}</span>
                        </div>
                        <div class="confrontation-content text-xs text-gray-300">
                            <div class="mb-1">
                                <span class="text-blue-400">Arc:</span> ${confrontation.identity_label || 'Unknown'}
                            </div>
                            <div class="mb-1">
                                <span class="text-red-400">Severity:</span> 
                                <div class="inline-block w-16 bg-gray-700 rounded-full h-1 ml-1">
                                    <div class="bg-red-400 h-1 rounded-full" style="width: ${Math.round(confrontation.severity * 100)}%"></div>
                                </div>
                                <span class="text-xs ml-1">${Math.round(confrontation.severity * 100)}%</span>
                            </div>
                            <div class="confrontation-message text-gray-400 italic">
                                ${confrontation.message || 'No message available'}
                            </div>
                        </div>
                    </div>
                `).join('');
            } else {
                stats.innerHTML = '<span class="text-gray-400">No confrontations logged yet</span>';
                list.innerHTML = '<p class="text-gray-400">No confrontations detected in this campaign.</p>';
            }
        }

        // Auto-refresh transformation and resolution after each turn
        async function postTurnRefresh() {
            await Promise.all([
                refreshTransformation(),
                refreshResolution(),
                refreshConfrontationLog()
            ]);
        }

        // Patch sendAction to auto-refresh transformation/resolution
        const originalSendAction = sendAction;
        sendAction = async function(event) {
            await originalSendAction(event);
            await postTurnRefresh();
        };

        // Initial load
        refreshTransformation();
        refreshResolution();
        refreshConfrontationLog();

        // Ending Detection and Cinematic Display
        let endingDetected = false;
        let currentEnding = null;
        let currentEpilogue = null;

        async function checkForEnding() {
            if (endingDetected) return; // Prevent multiple triggers
            
            try {
                const goals = lastInferredGoals || [];
                const transformation = lastTransformation || {};
                const resolution = lastResolution || {};
                const worldState = lastWorldState || {};
                
                const response = await fetch('/api/narrative/ending', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        goals: goals,
                        transformation: transformation,
                        resolution: resolution,
                        world_state: worldState
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.ending && data.ending.ending_triggered) {
                    endingDetected = true;
                    currentEnding = data.ending;
                    showCinematicEnding(data.ending);
                }
            } catch (error) {
                console.error('Error checking for ending:', error);
            }
        }

        function showCinematicEnding(ending) {
            const overlay = document.getElementById('cinematicEnding');
            const headline = document.getElementById('endingHeadline');
            const subtitle = document.getElementById('endingSubtitle');
            const typeIcon = document.getElementById('endingTypeIcon');
            const typeText = document.getElementById('endingTypeText');
            const transformationPath = document.getElementById('endingTransformationPath');
            const transformationDescription = document.getElementById('endingTransformationDescription');
            const goalsList = document.getElementById('endingGoalsList');
            
            // Set ending type display
            const endingConfig = getEndingConfig(ending.ending_type);
            typeIcon.innerHTML = endingConfig.icon;
            typeText.textContent = endingConfig.title;
            subtitle.textContent = ending.justification;
            
            // Set transformation summary
            if (lastTransformation) {
                transformationPath.textContent = lastTransformation.transformation_type || 'Unknown';
                transformationDescription.textContent = lastTransformation.description || 'No description available';
            }
            
            // Set goals recap
            if (lastInferredGoals && lastInferredGoals.length > 0) {
                goalsList.innerHTML = lastInferredGoals.map(goal => 
                    `<div class="goal-item">
                        <strong>${goal.type}</strong> - ${(goal.confidence * 100).toFixed(0)}% confidence
                    </div>`
                ).join('');
            } else {
                goalsList.innerHTML = '<div class="goal-item">No goals recorded</div>';
            }
            
            // Show overlay
            overlay.classList.remove('hidden');
            setTimeout(() => overlay.classList.add('show'), 100);
            
            // Disable input
            document.getElementById('playerInput').disabled = true;
            document.getElementById('sendButton').disabled = true;
            
            // Finalize campaign archive
            finalizeCampaignArchive(ending);
        }

        function getEndingConfig(endingType) {
            const configs = {
                'triumph': {
                    icon: '<i class="fas fa-crown"></i>',
                    title: 'Triumphant Victory'
                },
                'tragedy': {
                    icon: '<i class="fas fa-skull"></i>',
                    title: 'Tragic Loss'
                },
                'rebirth': {
                    icon: '<i class="fas fa-seedling"></i>',
                    title: 'Rebirth & Renewal'
                },
                'sacrifice': {
                    icon: '<i class="fas fa-heart"></i>',
                    title: 'Noble Sacrifice'
                },
                'redemption': {
                    icon: '<i class="fas fa-dove"></i>',
                    title: 'Redemption Found'
                },
                'bittersweet': {
                    icon: '<i class="fas fa-balance-scale"></i>',
                    title: 'Bittersweet Ending'
                }
            };
            return configs[endingType] || configs['bittersweet'];
        }

        async function generateEpilogue() {
            try {
                const memoryLog = []; // Could be populated from actual memory data
                const goalsAchieved = lastInferredGoals || [];
                const characterStats = {}; // Could be populated from character data
                const transformationPath = lastTransformation || {};
                const worldStateFlags = lastWorldState || {};
                const endingType = currentEnding ? currentEnding.ending_type : 'bittersweet';
                
                const response = await fetch('/api/narrative/epilogue', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        memory_log: memoryLog,
                        goals_achieved: goalsAchieved,
                        character_stats: characterStats,
                        transformation_path: transformationPath,
                        world_state_flags: worldStateFlags,
                        ending_type: endingType
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.epilogue) {
                    currentEpilogue = data.epilogue;
                    showEpiloguePanel(data.epilogue);
                }
            } catch (error) {
                console.error('Error generating epilogue:', error);
            }
        }

        function showEpiloguePanel(epilogue) {
            const panel = document.getElementById('epiloguePanel');
            const title = document.getElementById('epilogueTitle');
            const text = document.getElementById('epilogueText');
            const quoteContainer = document.getElementById('epilogueQuoteContainer');
            
            title.textContent = `Epilogue - ${epilogue.epilogue_theme}`;
            text.innerHTML = `<p>${epilogue.epilogue_text}</p>`;
            
            if (epilogue.epilogue_quotes && epilogue.epilogue_quotes.length > 0) {
                quoteContainer.innerHTML = epilogue.epilogue_quotes.map(quote => 
                    `<div class="mb-2">"${quote}"</div>`
                ).join('');
            }
            
            panel.classList.remove('hidden');
            setTimeout(() => panel.classList.add('show'), 100);
        }

        // Event listeners for ending actions
        document.addEventListener('DOMContentLoaded', function() {
            const revealEpilogueBtn = document.getElementById('revealEpilogueBtn');
            const replayEpilogueBtn = document.getElementById('replayEpilogueBtn');
            const downloadEpilogueBtn = document.getElementById('downloadEpilogueBtn');
            const newGamePlusBtn = document.getElementById('newGamePlusBtn');
            const newGameBtn = document.getElementById('newGameBtn');
            const exitGameBtn = document.getElementById('exitGameBtn');
            const closeEpilogueBtn = document.getElementById('closeEpilogueBtn');
            const printEpilogueBtn = document.getElementById('printEpilogueBtn');
            const shareEpilogueBtn = document.getElementById('shareEpilogueBtn');
            
            if (revealEpilogueBtn) {
                revealEpilogueBtn.addEventListener('click', generateEpilogue);
            }
            
            if (replayEpilogueBtn) {
                replayEpilogueBtn.addEventListener('click', replayEpilogue);
            }
            
            if (downloadEpilogueBtn) {
                downloadEpilogueBtn.addEventListener('click', () => {
                    if (currentEpilogue) {
                        const content = `# SoloHeart Epilogue\n\n${currentEpilogue.epilogue_text}\n\nTheme: ${currentEpilogue.epilogue_theme}\n\nQuotes:\n${currentEpilogue.epilogue_quotes.join('\n')}`;
                        const blob = new Blob([content], { type: 'text/markdown' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'soloheart-epilogue.md';
                        a.click();
                        URL.revokeObjectURL(url);
                    }
                });
            }
            
            if (newGamePlusBtn) {
                newGamePlusBtn.addEventListener('click', createNewGamePlus);
            }
            
            if (newGameBtn) {
                newGameBtn.addEventListener('click', () => {
                    window.location.href = '/character-creation';
                });
            }
            
            if (exitGameBtn) {
                exitGameBtn.addEventListener('click', () => {
                    window.location.href = '/';
                });
            }
            
            if (closeEpilogueBtn) {
                closeEpilogueBtn.addEventListener('click', () => {
                    document.getElementById('epiloguePanel').classList.remove('show');
                    setTimeout(() => document.getElementById('epiloguePanel').classList.add('hidden'), 600);
                });
            }
            
            if (printEpilogueBtn) {
                printEpilogueBtn.addEventListener('click', () => {
                    window.print();
                });
            }
            
            if (shareEpilogueBtn) {
                shareEpilogueBtn.addEventListener('click', () => {
                    if (navigator.share && currentEpilogue) {
                        navigator.share({
                            title: 'My SoloHeart Epilogue',
                            text: currentEpilogue.epilogue_text,
                            url: window.location.href
                        });
                    } else {
                        // Fallback: copy to clipboard
                        navigator.clipboard.writeText(currentEpilogue ? currentEpilogue.epilogue_text : '');
                        alert('Epilogue copied to clipboard!');
                    }
                });
            }
            
            if (downloadEpilogueBtn) {
                downloadEpilogueBtn.addEventListener('click', () => {
                    if (currentEpilogue) {
                        const content = `# SoloHeart Epilogue\n\n${currentEpilogue.epilogue_text}\n\nTheme: ${currentEpilogue.epilogue_theme}\n\nQuotes:\n${currentEpilogue.epilogue_quotes.join('\n')}`;
                        const blob = new Blob([content], { type: 'text/markdown' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'soloheart-epilogue.md';
                        a.click();
                        URL.revokeObjectURL(url);
                    }
                });
            }
        });

        // Archive functionality
        async function finalizeCampaignArchive(ending) {
            try {
                const characterData = {}; // Could be populated from character data
                const worldState = lastWorldState || {};
                const goals = lastInferredGoals || [];
                const transformation = lastTransformation || {};
                const endingSummary = ending;
                
                const response = await fetch('/api/archive/finalize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_data: characterData,
                        world_state: worldState,
                        goals: goals,
                        transformation: transformation,
                        ending_summary: endingSummary
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    console.log('Campaign archived successfully:', data.archive_file);
                }
            } catch (error) {
                console.error('Error finalizing campaign archive:', error);
            }
        }

        async function replayEpilogue() {
            try {
                // Load saved epilogue from archive
                const response = await fetch('/api/archive/list');
                const data = await response.json();
                
                if (data.success && data.archives.length > 0) {
                    const latestArchive = data.archives[0];
                    const archiveResponse = await fetch(`/api/archive/load?file=${latestArchive.filename}`);
                    const archiveData = await archiveResponse.json();
                    
                    if (archiveData.success && archiveData.archive_data.epilogue) {
                        currentEpilogue = archiveData.archive_data.epilogue;
                        showEpiloguePanel(currentEpilogue);
                        
                        // Show replay and download buttons
                        document.getElementById('replayEpilogueBtn').style.display = 'inline-block';
                        document.getElementById('downloadEpilogueBtn').style.display = 'inline-block';
                    }
                }
            } catch (error) {
                console.error('Error replaying epilogue:', error);
            }
        }

        async function createNewGamePlus() {
            try {
                const legacyOptions = {
                    memories: true,
                    stat_bonuses: true,
                    items: true
                };
                
                const response = await fetch('/api/campaign/newgameplus', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        legacy_options: legacyOptions
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    alert('New Game+ created! Starting new adventure...');
                    window.location.href = '/game';
                }
            } catch (error) {
                console.error('Error creating New Game+:', error);
            }
        }

        // Auto-check for ending after each turn
        const originalPostTurnRefresh = postTurnRefresh;
        postTurnRefresh = async function() {
            await originalPostTurnRefresh();
            await checkForEnding();
        };

        // Add to dev context block
        function showContextBlock() {
            // Remove existing context block
            const existingContext = document.querySelector('.context-block');
            if (existingContext) {
                existingContext.remove();
            }
            
            // Create context block
            const contextBlock = document.createElement('div');
            contextBlock.className = 'context-block bg-gray-800 bg-opacity-50 border border-yellow-400 border-opacity-30 rounded-lg p-4 mb-4 text-xs text-gray-300';
            contextBlock.innerHTML = `
                <div class="flex items-center justify-between mb-2">
                    <span class="text-yellow-400 font-semibold">Developer Context</span>
                    <button onclick="hideContextBlock()" class="text-gray-400 hover:text-white">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="context-content">
                    <div class="mb-2">
                        <span class="text-blue-400">Memory Context:</span>
                        <div class="ml-2 text-gray-400">${lastMemoryContext ? JSON.stringify(lastMemoryContext, null, 2) : 'No memory context available'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-purple-400">Symbolic Tags:</span>
                        <div class="ml-2 text-gray-400">${lastSymbolicTags ? JSON.stringify(lastSymbolicTags, null, 2) : 'No symbolic tags available'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-green-400">Inferred Goals:</span>
                        <div class="ml-2 text-gray-400">${lastInferredGoals ? JSON.stringify(lastInferredGoals, null, 2) : 'No goals available'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-blue-400">World State:</span>
                        <div class="ml-2 text-gray-400">${lastWorldState ? JSON.stringify(lastWorldState, null, 2) : 'No world state available'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-yellow-400">Transformation:</span>
                        <div class="ml-2 text-gray-400">${lastTransformation ? JSON.stringify(lastTransformation, null, 2) : 'No transformation available'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-green-400">Resolution:</span>
                        <div class="ml-2 text-gray-400">${lastResolution ? JSON.stringify(lastResolution, null, 2) : 'No resolution available'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-purple-400">Ending Check:</span>
                        <div class="ml-2 text-gray-400">${currentEnding ? JSON.stringify(currentEnding, null, 2) : 'No ending detected'}</div>
                    </div>
                    <div class="mb-2">
                        <span class="text-orange-400">Epilogue Seed:</span>
                        <div class="ml-2 text-gray-400">${currentEpilogue ? JSON.stringify(currentEpilogue, null, 2) : 'No epilogue generated'}</div>
                    </div>
                </div>
            `;
            
            // Insert at the top of game container
            const gameContainer = document.getElementById('gameContainer');
            const settingIntro = document.getElementById('settingIntroduction');
            if (settingIntro) {
                gameContainer.insertBefore(contextBlock, settingIntro.nextSibling);
            } else {
                gameContainer.insertBefore(contextBlock, gameContainer.firstChild);
            }
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (contextDisplayVisible) {
                    hideContextBlock();
                }
            }, 10000);
        }

        // Session Management Functions
        async function loadSessions() {
            try {
                const response = await fetch('/api/sessions');
                const data = await response.json();
                
                if (data.success) {
                    updateSessionDisplay(data.sessions);
                } else {
                    console.error('Failed to load sessions:', data.error);
                }
            } catch (error) {
                console.error('Error loading sessions:', error);
            }
        }

        function updateSessionDisplay(sessions) {
            const sessionList = document.querySelector('.session-list');
            const sessionStats = document.querySelector('.session-stats');
            
            if (sessions.length === 0) {
                sessionList.innerHTML = '<p class="text-gray-400">No sessions available.</p>';
                sessionStats.innerHTML = '<span class="text-cyan-400">No sessions found</span>';
                return;
            }
            
            sessionStats.innerHTML = `<span class="text-cyan-400">${sessions.length} session(s)</span>`;
            
            const sessionHtml = sessions.map(session => `
                <div class="session-item mb-2 p-2 bg-gray-800 rounded border border-gray-700">
                    <div class="session-name text-cyan-400 font-semibold text-xs">${session.name}</div>
                    <div class="session-campaign text-gray-400 text-xs">Campaign: ${session.campaign_id}</div>
                    <div class="session-date text-gray-500 text-xs">${formatDate(session.created_at)}</div>
                    <div class="session-actions flex gap-1 mt-1">
                        <button onclick="loadSession('${session.session_id}')" class="text-xs text-green-400 hover:text-green-300">
                            <i class="fas fa-play mr-1"></i>Load
                        </button>
                        <button onclick="renameSession('${session.session_id}', '${session.name}')" class="text-xs text-yellow-400 hover:text-yellow-300">
                            <i class="fas fa-edit mr-1"></i>Rename
                        </button>
                        <button onclick="deleteSession('${session.session_id}')" class="text-xs text-red-400 hover:text-red-300">
                            <i class="fas fa-trash mr-1"></i>Delete
                        </button>
                    </div>
                </div>
            `).join('');
            
            sessionList.innerHTML = sessionHtml;
        }

        async function loadSession(sessionId) {
            try {
                const response = await fetch('/api/sessions/load', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });
                
                const data = await response.json();
                if (data.success) {
                    // Reload the page with the new session
                    window.location.reload();
                } else {
                    console.error('Failed to load session:', data.error);
                }
            } catch (error) {
                console.error('Error loading session:', error);
            }
        }

        async function renameSession(sessionId, currentName) {
            const newName = prompt('Enter new session name:', currentName);
            if (!newName || newName.trim() === '') return;
            
            try {
                const response = await fetch('/api/sessions/rename', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        session_id: sessionId,
                        new_name: newName.trim()
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    // Refresh session list
                    await loadSessions();
                } else {
                    console.error('Failed to rename session:', data.error);
                }
            } catch (error) {
                console.error('Error renaming session:', error);
            }
        }

        async function deleteSession(sessionId) {
            if (!confirm('Are you sure you want to delete this session? This action cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch('/api/sessions/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });
                
                const data = await response.json();
                if (data.success) {
                    // Refresh session list
                    await loadSessions();
                } else {
                    console.error('Failed to delete session:', data.error);
                }
            } catch (error) {
                console.error('Error deleting session:', error);
            }
        }

        function showNewSessionModal() {
            const campaignId = prompt('Enter campaign ID (optional):');
            if (campaignId === null) return; // User cancelled
            
            // Create new session by redirecting to new game
            const url = campaignId && campaignId.trim() !== '' 
                ? `/game/new?campaign=${encodeURIComponent(campaignId.trim())}`
                : '/game/new';
            
            window.location.href = url;
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        }

        // Load sessions on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadSessions();
        });
    </script>
</body>
</html> 